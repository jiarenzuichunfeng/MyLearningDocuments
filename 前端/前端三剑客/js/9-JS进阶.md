# JS 进阶

## 作用域

* 作用域规定了变量能够被访问的范围
* 局部作用域
  * 局部作用域分为函数作用域和块作用域
  * 在函数内部声明的变量只能在函数内部访问，外部无法直接访问。
  * 函数的形参也可以看做是内部的局部变量
  * 块作用域
    * 使用{}包裹的代码称为代码块
    * let/const声明的会产生块作用域，var不会产生
    * 不同代码块之间的变量无法互相访问
* 全局作用域

  * \<script> 标签和.js文件的最外层就是所谓的全局作用域，在此声明的变量在函数内部也可以被访问。
  * 全局作用域中声明的变量，任何其他作用域都可以被访问
  * 为window对象动态添加的属性默认是全局的
  * 函数中未使用任何关键字声明的变量，是全局的
* 作用域链

  * 嵌套关系的作用域串联起来形成了作用域链
  * 作用
    * 作用域链的本质是底层的变量查找机制（就近原则）
    * 函数被执行时，会优先查找当前函数作用域中查找变量
    * 没有则会逐级向上查找父级作用域直到全局作用域
* 垃圾回收机制GC

  * JS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收
  * 内存的生命周期
    * 内存分配：声明变量、函数、对象
    * 内存使用：即读写内存，也就是使用变量、函数等
    * 内存回收：使用完毕，有垃圾回收器自动回收不在使用的内存
  * 说明
    * 全局变量一般不会回收（关闭页面回收）
    * 一般情况下局部变量的值，不用了，会被自动回收掉
  * 内存泄漏
    * 程序中分配的内存由于某种原因程序未释放或无法释放叫做内存泄漏
* 闭包

  * 概念
    * 一个函数对周围状态的引用捆绑在一起，闭包让开发者可以从内部函数访问外部函数的作用域
    * 简单理解：闭包 = 内层函数 + 外层函数的变量
  * 作用
    * 实现数据的私有，避免全局的污染，外层函数也可以访问里层函数的变量
  * 可能会造成内存泄漏
* 变量提升

  * 变量提升是JavaScript中比较奇怪的现象，他允许变量在声明前被访问（只存在var声明的变量中）
  * 变量提升会提升到当前作用域的最前面
  * 只提升变量声明，不提升变量赋值
* 函数提升

  * 函数提升到当前作用域最前面
  * 函数提升只提升声明，不提升调用
  * 函数表达式不存在提升的现象


## 函数参数

* 函数参数的使用细节，能够提升函数应用的灵活度
* arguments对象
  * arguments是函数内部内置的对象（伪数组），它包含了调用函数时传入的所有实参
  * arguments的作用动态获取函数的实参
  * 可以通过for循环一次得到传递过来的值
* 剩余参数
  * 允许我们将一个不定属性的参数表示为一个数组
  * 用于获取多余的实参，并形成一个真数组
* 剩余参数和arguments的区别
  * ...是语法符号，置于最末函数形参之前，用于获取多余的实参
  * 借助...获取的剩余实参是真数组
  * 箭头函数不支持arguments，但是可以使用剩余参数】
* 展开运算符
  * ...，将一个数组/对象进行展开

## 箭头函数

* 写法
  * （）=> {}
* 如果只有一个形参，则可以省略小括号
* 如果函数体只有一句代码，大括号可以省略，这句代码就是返回值
* 如果返回的是一个对象，则需要用小括号把大括号给包裹
* 箭头函数没有this，它只会沿用上一级的作用域

## ES6中的对象属性和方法的简写



* 在对象中，如果属性名和属性值一致，可以简写只写属性名即可
* 在对象中吗，方法（函数）可以简写
  * 方法名（）{}

## 解构赋值

* 解构赋值：可以将数组中的值或对象的属性取出，赋值给其他变量
* 解构：其实就是把一个事务的结构进行拆解
* 写法
  * 声明 【变量名,变量名1】 = 【值1，值2】
  * 声明 {属性名，属性名} = 对象名
* 解构重命名
  * 声明 {属性名 ： 新的名字，属性名} = 对象名

## 筛选数组 filter方法

* filter方法创建一个新的数组，新数组中的元素是符合条件的所有元素
* 语法
  * 声明 新的数组名 = 数组名.filter(function（element，index）{
    return 筛选条件
    })
    element 数组元素
    index 数组元素索引号

## JS垃圾回收机制

* 引用计数法
  * 跟踪记录被引用的次数
  * 如果被引用了一次，那么就记录次数1，多次引用或累加
  * 如果减少一个引用就减一
  * 如果引用次数是0，则释放内存
  * 循环引用无法自动进行回收
* 标记清除法
  * 标记清除法将不在使用的对象定义为无法达到的对象
  * 就是从根部出发定时扫描内存中的对象，凡是能从根部到达的对象，都是还需要使用的
  * 那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收

## 创建对象的三种方式

1. 利用对象字面量创建对象
   1. 声明 对象名 = {}
2. 利用 new Object 创建对象
   1. 声明 对象名 = new Object（{}）
3. 利用构造函数创建对象
   1. 构造函数：是一种特殊的函数，主要用来创建对象
   2. 约定
      1. 命名以大写字母开头
      2. 通过new 关键字来调用构造函数
   3. 公共属性进行封装，通过new出实例化对象
4. 实例成员&静态成员
   1. 在实例化对象身上增加的属性和方法叫做实例成员
   2. 在构造函数中的属性和方法被称为静态成员

## 内置构造函数

### Object常用静态方法

* Object.keys() 获取所有的键名
* Object.value() 获取所有的值
* Object.assign(拷贝放在那个对象中，要拷贝的对象) 对对象进行拷贝

### Array常用实例方法

* forEach 遍历数组 
* filter 过滤数组 返回新数组，返回的是满足筛选条件的数组元素
* map 迭代数组 返回新数组，返回的是处理之后的数组元素
* reduce 累计器 返回累计处理的结果
  * 语法
    * 数组名.reduce(处理函数（上一次的值，当前值）,起始值)
* join 数组元素拼接为字符串，返回字符串
* find 查找元素，返回符合测试条件的第一个数组元素值，如果没有符合条件则返回undefined
* every 检测数组所有元素是否都符合指定条件，如果所有元素都通过检测返回true，否则返回false
* some 检测数组中的元素是否满足指定条件，如果数组中有元素满足条件返回true，否则返回false
* concat 合并两个数组，返回新生成的数组
* sort 对原数组进行排序
* splice 删除或替换原数组单元
* reverse 反转数组
* findIndex 查找元素的索引值
* Array.from() 静态方法，把伪数组转为真数组，不对原数组进行更改

### String

* length 获取字符串长度
* split（‘分割符’）用来将字符串拆分成数组
* substring （需要截取的第一个字符的索引【，结束的索引号】） 用于字符串截取
* startsWith （检测字符串【，检测位置索引号】）检测是否以某字符开头
* includes （搜索的字符串【，检测位置索引号】）判断一个字符串是否包含在另一个字符串中，根据情况返回true或false
* trim（）字符串两端清除空格，返回一个新的字符串，而不修改原始字符串
* toUpperCase 用于将字母转换成大写
* toLowerCase 用于将字母转换成小写
* indexof 检测是否包含某个字符
* endsWith 检测是否以某字符结尾
* replace 用于替换字符串，支持正则
* match 用于查找字符串，支持正则

## 深入面向对象

* 编程思想

  * 面向过程
    * 分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现
  * 面向对象
    * 把事务分解成一个对象，然后由对象之间分工合作
    * 特性
      * 封装
      * 继承
      * 多态
  * 对比
    * 面向过程：
      * 优点
        * 性能比面向对象高
      * 缺点
        * 不灵活、复用性较差
    * 面向过程
      * 优点
        * 易维护、易复用、易扩展
      * 缺点
        * 性能比面向过程低
* 构造函数实习封装 会造成内存浪费
* 原型对象

  * JS中，每一个构造函数都有一个prototype属性，指向另一个对象，所以我们也称为原型对象
  * 原型对象可以挂载函数，对象实例化不会多次创建原型对象里面的函数，节约内存
  * this指向
    * 指向实例化对象（谁调用指向谁）
  * constructor
    * 每个原型对象里面都有
    * 该属性指向该原型对象的构造函数
* 对象原型

  * 对象都有一个属性\__proto__指向构造函数的prototype原型对象
* 原型链

  * \__proto__属性链状结构被称为原型链
  * 原型链为对象成员查找机制提供一个方向，或者说一条路线
  * instanceof运算符
    * 实例对象 instanceof 构造函数
    * 作用
      * 用来检测构造函数的原型对象是不是在实例对象的原型链上
* 原型继承

  * 公共属性和方法可以写在父级身上，子集通过继承可以使用这些属性和方法
  * js是借助原型对象来实现继承


## 深浅拷贝

* 浅拷贝
  * 把对象拷贝给一个新的对象，开发中我们经常需要赋值一个对象
  * 拷贝对象
    * Object.assign()
    * 展开运算符
  * 拷贝数组
    * Array.concat（）
    * 展开运算符
  * 多层对象或数组，内层数租或对象会有影响
  
* 深拷贝
  * 拷贝多层，不拷贝地址
  
  * 创建方法
    * 通过JSON序列化
      * JSON.stringify() 转为字符串 
        * 注意：会忽略函数和undefined
  
      * JSON.parse（） 转为对象
  
    * 通过Lodash库
      * [Lodash 简介 | Lodash中文文档 | Lodash中文网](https://www.lodashjs.com/)
  
    * 通过递归
    
      * 递归
    
        * 函数自己调用自己
        * 递归函数的作用和循环效果类似
        * 记得添加退出条件 return 退出条件
    
      * ```js
         // 深拷贝 递归实现
            function cloneDeep(oldObj) {
              // 判断是数组还是对象
              const newObj = Array.isArray(oldObj) ? [] : {};
              // 遍历拷贝属性和值
              for (const key in oldObj) {
                if (typeof oldObj[key] === "object") {
                  newObj[key] = cloneDeep(oldObj[key]);
                } else {
                  newObj[key] = oldObj[key];
                }
              }
              return newObj;
            }
        ```

## throw 抛异常

* 异常处理是指预估代码执行过程中可能发生的错误，然后最大程度的避免错误的发生导致整个程序无法继续运行
* 通常配合 Error 对象来使用
* try/catch 捕获错误信息
  * try 试试 catch 拦住 finally 最后

## debugger

* 在想要调试语句的上放写上语句 debugger

## 改变this

* js中允许指定（改变）函数中this的指向
* call（）
  * call方法可以调用函数，同时指定被调用函数中的this指向
  * 函数.call(函数运行时指定的this值，函数实参)
  *  Object.prototype.toString.call（） 精准匹配数据类型
* apply（）
  * apply方法可以调用函数，同时指定被调用函数中的this指向
  * 函数.apply(函数运行时指定的this值，[函数实参])
* bind（)
  * 不会调用函数，指定被调用函数中的this指向
  * 函数.bind(函数运行时指定的this值，函数实参)
  * 返回一个新函数

## 防抖

* 单位时间内，频繁触发事件，只执行最后一次

* lodash实现防抖

* 手写防抖函数

  * 核心思路

    * 利用定时器setTimeout来实现
      1. 声明一个定时器变量
      2. 当触发这个事件的时候，先判断是否有定时器了，如果有则先清除以前的定时器
      3. 如果没有则开启定时器，并存到变量中，用于关闭定时器
      4. 在定时器里调用要执行的函数
    
    ```js
     func 是函数，time 是时间
    function debounce(func, time) {
          // 声明定时器变量 用于清除定时器
          let timer;
          // 返回一个匿名函数
          return function () {
            // 判断有没有定时器，有就执行删除
            if (timer) clearTimeout(timer);
            timer = setTimeout(function () {
              func();
            }, time);
          };
        }
    ```

## 节流

* 单位时间内，频繁触发事件，只执行一次

* lodash实现节流

* 手写节流函数

  * 核心思路
  
    * 利用定时器setTimeout来实现
      1. 声明一个定时器变量
      2. 当触发这个事件的时候，先判断是否有定时器了，如果有则不开启新的定时器了
      3. 如果没有定时器则开启定时器，并存到变量中。
         1. 在定时器里调用要执行的函数
         2. 函数执行完，把定时器清空
  
  * ```js
    function throttle(func,time){
          let timer;
    
          return function(){
            if(!timer){
              timer = setTimeout(function(){
                func()
                // 清空定时器
                timer = null
              },time)
            }
          }
        }
    ```
