# 网络请求

## AJAX

* 定义
  * AJAX是异步的JS和XML，简单来说就是使用XMLHttpRequest对象与服务器通信。它可以使用JSON、XML、HTML、text文本等格式发送和接受数据

### axios 库

* [axios中文文档|axios中文网 | axios](http://www.axios-js.com/zh-cn/docs/)
* axios基地址
  * baseURL将自动加在url前面，除非url是一个绝对URL，它可以通过设置一个baseURL便于为axios实例的方法传递相对的URL
  * 设置axios基地址
    * axios.defaults.baseURL = 基地址
* axios请求拦截器
  * 作用
    * 请求发送之前，响应回来之后执行一些公共的逻辑

  * 请求拦截器语法：
    * axios.interceptors.request.use(成功回调，失败回调)

* axios 响应拦截器
  * 作用
    * 对响应结果，进行处理

  * 响应拦截器语法：
    * axios.interceptors.response.use(成功回调，失败回调)


### JWT

* JSON Web Token是目前最为流行的跨域认证解决方案
* 作用：允许用户访问使用令牌，允许访问的路由、服务和


### URL

* URL无非就是一个给定的独特资源在web上的地址，每个有效的URL都指向一个唯一的资源，这个资源可以是一个HTML页面，一个css文档，一副图像等等。
* URL常见的组成部分
  * 协议
    * 规定了浏览器发送以及服务器返回内容的格式，常见的有http、https
  * 域名
    * 表示正在请求网络上的哪个服务器
  * 资源路径
    * 资源在服务器的位置，资源和路径的对应关系由服务器决定
* URL查询参数
  * URL查询参数是提供给网络服务器的额外参数
  * ？表示往后的是查询参数
  * 键 = 值 & 键 = 值 &链接多个键值对

### http协议

* 规定了浏览器发送以及服务器返回内容的格式

#### 请求报文

* 浏览器按照HTTP协议要求的格式，发送给服务器的内容
* 组成格式
  * 请求行：请求方法，URL，协议
  * 请求头：以键值对的格式携带的附加信息
  * 空行：分割请求头，空行之后是发送给服务器的资源
  * 请求体：发送的资源

#### 响应报文

* 服务器按照HTTP协议要求的格式，返回给浏览器的内容
* 组成格式
  * 响应行：请求方法，HTTP响应状态码，状态信息
  * 响应头：以键值对的格式携带的附加信息
  * 空行：分割请求头，空行之后是返回给浏览器的资源
  * 响应体：返回的资源
* HTTP响应状态码
  * 1xx 信息
  * 2xx 成功
  * 3xx 重定向
  * 4xx 客户端错误
  * 5xx 服务端错误

### 接口文档

* 描述接口的文章
* 接口：使用AJAX和服务器通讯时，使用的URL，请求方法，以及参数

### [【AJAX】Form-serialize插件的使用详解-CSDN博客](https://blog.csdn.net/lph159/article/details/142307746)

### 图片上传

1. 选择图片

2. 使用FromDate对象

3. 调用接口

 ```html
    <input type="file" class="upload">
       <img src="" class="img" alt="">
       <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
       <script>
       //  图片上传
       // 选择图片
       document.querySelector('.upload').addEventListener('change', function (e) {
       console.log(this.files[0]);
   
       // 创建FormData对象
       const formData = new FormData();
       // 参数1，接口文档要求的参数名
       // 参数2，文件对象
       formData.append('img', this.files[0]);
   
       // 调用接口
       axios({
         url:'https://hmajax.itheima.net/api/uploadimg',
         method: 'post',
         data: formData,
       }).then(res=>{
         const url = res.data.data.url;
         document.querySelector('.img').src = url;
       })
       
       });
       </script>
 ```

### XMLHttpRequest

* XMLHttpRequest对象用于与服务器交互

* 步骤

  1. 创建xhr对象
  2. 设置请求方法和请求URL
  3. 监听loadend事件，接受响应结果
  4. 发起请求

  ```html
   <p class="list"></p>
  // 创建 XMLHttpRequest 对象
      const xhr = new XMLHttpRequest();
      // 设置请求方法和URL
      xhr.open('GET', 'https://hmajax.itheima.net/api/province');  
      // 监听loadend事件，接受响应数据
      xhr.addEventListener('loadend', function () {
        const data = JSON.parse(xhr.response);
        document.querySelector('.list').innerText = data.list
      });
      // 发送请求
      xhr.send();
  ```

* xhr查询参数

  * 需要在设置URL中手动添加
  * 通过 URLSearchParams对象

* 向服务器发送数据的时候得设置它的请求头

  * xhr.setRequestHeader('Content-Type', 'application/json;charset=UTF-8');

## 认识Promise

* 定义 Promise对象用于表示一个异步操作的最终完成（或失败）及其结果值

* 使用步骤

  * 1-实例化Promise 

    * const 对象名 = new Promise（（resolve,reject）=》{

        2-异步操作，并传递结果

         resolve（成功）

         reject（失败）

      }）

    * 3-接受结果

      * 对象名.then(res=>{}（成功处理函数）).catch(err=>{}（失败处理函数）)

* Promise状态
  * 定义：一个Promise必然处于一下几种状态之一
    1. 待定（pending）：初始状态，既没有被兑现，也没有被拒绝
    2. 已兑现（fullfilled）：意味着操作成功完成
    3. 已拒绝（rejected）：意味着操作失败

* 同步和异步代码
  * 同步代码：浏览器是按照我们书写代码的顺序一行一行地执行程序的。浏览器会等待代码的解析和工作，在上一行完成后才会执行下一行。
  * 同步代码：逐行执行，需要原地等待结果后，才继续向下执行
  * 异步代码：异步编程技术使你的程序可以在执行一个可能长期运行的任务的同时继续对其他事件做出反应而不必等待任务完成
  * 异步代码：调用后耗时，不阻塞代码继续执行，在将来完成后触发一个回调函数
* 回调函数地狱
  * 在回调函数中调用回调函数，形成的代码结构称之为回调函数地狱
  * ![image-20250716193737016](D:\study\lianxi\MyLearningDocuments\images\image-20250716193737016.png)
  * 缺点：可读性差，异常捕获困难
* Promise 链式调用（解决回调地狱）
  * 每一个then方法会返回一个新生产的Promise对象，这个对象可被用作链式调用
  * then方法中回函数的返回值，会影响新生成的Promise对象最终状态和结果
* async函数和await
  * async函数是使用async关键字声明的函数。async和await关键字让我们可以用一种更简洁的方式写出基于Promise的异步行为，而无需刻意地链式调用Promise
  * 语法：在async函数内，使用await关键字取代then函数，等待获取Promise对象成功状态的结果值
  * 错误捕获
    * 使用async/await关键字就可以在异步代码中使用普遍的try/catch代码块
* Promise.all静态方法
  * 集合多个和Promise的返回结果
  * 作用：将多个Promise对象包装成一个新的Promise对象，获取所有的成功结果，或者某一个失败原因
  * ![image-20250716213944553](D:\study\lianxi\MyLearningDocuments\images\image-20250716213944553.png)
  * ![image-20250716214146297](D:\study\lianxi\MyLearningDocuments\images\image-20250716214146297.png)
  * 

## 事件循环-eventloop

* js是单线程的，为了不让耗时代码阻塞其他代码运行，就设计了事件循环
* 定义：js有一个基于事件循环的并发模型，事件循环负责执行代码、收集和处理事件以及执行队列中的子任务

### 事件循环-执行过程

* 调用栈执行同步代码，异步代码交给宿主环境执行，异步代码等待时机成熟，送入任务队列排队，调用栈空闲时，反复查看并调用任务队列里的回调函数

### 异步任务有两类 宏任务和微任务

* 宏任务：由浏览器执行的异步代码
  * ![image-20250716212308925](D:\study\lianxi\MyLearningDocuments\images\image-20250716212308925.png)
* 微任务：由js引擎环境执行的异步代码
  * ![image-20250716212318474](D:\study\lianxi\MyLearningDocuments\images\image-20250716212318474.png)
  * Promise本身是同步的，then和catch回调函数是异步的
* ![image-20250716212448572](D:\study\lianxi\MyLearningDocuments\images\image-20250716212448572.png)
* 