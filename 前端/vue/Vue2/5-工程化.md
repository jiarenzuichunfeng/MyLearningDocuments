# Vue工程化开发

* 脚手架 Vue CLI
  * Vue CLI 是Vue官方提供的一个全局命令工具
  * 可以帮助我们快速创建一个开发Vue项目的标准化基础架子
* 使用步骤
  * 全局安装 yarn global add @vue/cli 或 npm i @vue/cli -g
  * 查看Vue版本 vue --version
  * 创建项目架子 vue create 项目名
  * 启动项目 yarn serve 或 npm run serve
* 组件化开发
  * 组件化：一个页面可以拆分成一个个组件，每个组件有着自己独立的结构、样式、行为
    * 好处：便于维护，利于复用
  * 组件分类
    * 普通组件
    * 根组件：整个应用的最上层组件，包裹所有普通组件
  * template结构（只能有一个根节点）
  * style 样式（可以支持less和sass）
  * script 行为
* 普通组件的注册使用
  * 局部注册：只能在注册的逐渐内使用
    * 创建.vue文件
    * 在要使用的组件内导入，并进行局部注册
      * 在导出对象的components：{组件名：导入的对象}
  * 全局注册：所有组件内部都能使用
    * 在main.js中导入，并全局注册Vue.component(组件名,组件对象)

## 样式隔离

* 在style写的样式默认生成全局样式
* 在 style中加上scoped可以让当前样式作用于当前组件
* scoped原理
  * 给当前组件模板的所有元素，都会被添加上一个自定义属性 data-v-hash值
  * css选择器后面，被自动处理，添加上了属性选择器

## data是一个函数

* 一个组件的data选项必须是一个函数。保证每个组件实例，维护独立的一份数据对象

## 组件通信

* 组件通信，就是指组件与组件之间的数据传递

* 组件的数据是独立的，无法直接访问其他组件的数据

* 想用其他组件的数据-》组件通信

* 父传子 自定义属性

  * 父组件通过props将数据传递给子组件

    ``` vue
    <template>
      <div id="app">
        我是父组件
        <HelloWorld :message="message"/>
      </div>
    </template>
    <script>
    import HelloWorld from './components/HelloWorld.vue'
    export default {
      name: 'App',
      components: {
        HelloWorld
      },
      data() {
        return {
          message: 'Hello Vue!'
        }
      },
    }
    </script>
    ```

    ```vue
    <template>
      <div class="hello">
       我是子组件
        <h1>{{ message }}</h1>
      </div>
    </template>
    <script>
    export default {
      name: 'HelloWorld',
      props: [
        'message'
      ],
    }
    </script>
    ```

* 子传父 自定义事件

  * 子组件通过$emit通知父组件修改更新

    ```vue
    <template>
      <div id="app">
        我是父组件
        <HelloWorld :message="message" @changeemessage="updateMessage" />
      </div>
    </template>
    
    <script>
    import HelloWorld from './components/HelloWorld.vue'
    
    export default {
      name: 'App',
      components: {
        HelloWorld
      },
      data() {
        return {
          message: 'Hello Vue!'
        }
      },
      methods: {
        updateMessage(newMessage) {
          this.message = newMessage;
          console.log('父组件接收到子组件的消息:', this.message);
          
        }
      }
    }
    </script>
    
    <style>
    
    </style>
    
    ```

    ```vue
    <template>
      <div class="hello">
       我是子组件
        <h1>{{ message }}</h1>
        <button @click="changemes">修改message</button>
      </div>
    </template>
    
    <script>
    export default {
      name: 'HelloWorld',
      props: [
        'message'
      ],
      methods: {
        changemes() {
          this.$emit('changeemessage','子组件修改了message');
        }
      },
    }
    </script>
    
    <!-- Add "scoped" attribute to limit CSS to this component only -->
    <style scoped>
    
    </style>
    
    ```

    

* 兄弟之间通信 eventbus或provide&inject

  * eventbus 事件总线

    * 作用：非父子组件之间，进行简易消息传递（复杂场景-》Vuex）

      1. 创建一个都能范文到的事件总线（空Vue实例）-》vtils/EventBus.js

         ```js
         import Vue from 'vue'
         const Bus = new Vue()
         export default Bus
         ```

      2. 接收方，监听Bus实例的事件

         ```js
         created（）{
           Bus.$on(事件名字,(形参)=>{处理体})
         }
         ```

      3. 发送方，触发Bus实例的事件

         ```js
         Bus.$emit(事件名字，事件体)
         ```

  * provide&inject

    * 作用：跨层级共享数据

      ```vue
      <template>
        <div id="app">
          我是父组件
          <HelloWorld
            :message="message"
            @changeemessage="updateMessage"
            @changname="updateName"
          />
        </div>
      </template>
      
      <script>
      import HelloWorld from "./components/HelloWorld.vue";
      
      export default {
        name: "App",
        components: {
          HelloWorld,
        },
        data() {
          return {
            message: "Hello word!",//简单类型是非响应式的
            obje: {	             // 是响应式的
              name: "张三",
              age: 18,
            },
          };
        },
        provide() {
          return {
            mes: this.message,
            obje: this.obje,
          };
        },
        methods: {
          updateMessage(newMessage) {
            this.message = newMessage;
            console.log("父组件接收到子组件的消息:", this.message);
          },
          updateName(newName) {
            this.obje.name = newName;
            console.log("父组件接收到子组件的名字修改:", this.obje.name);
          },
        },
      };
      </script>
      
      <style></style>
      
      ```

      ```vue
      <template>
        <div class="hello">
          我是子组件
          <h1>{{ message }}</h1>
          <button @click="changemes">修改message</button>
          <h2>{{ mes }}</h2>
          <h2>{{ obje.name }} - {{ obje.age }}</h2>
        </div>
      </template>
      
      <script>
      export default {
        name: "HelloWorld",
        props: ["message"],
        inject: ["mes", "obje"],
        methods: {
          changemes() {
            this.$emit("changeemessage", "子组件修改了message");
            this.$emit("changname", "李四");
          },
        },
      };
      </script>
      
      <!-- Add "scoped" attribute to limit CSS to this component only -->
      <style scoped></style>
      
      ```

      

* prop

  * 定义：组件上注册的一些自定义属性
  * 作用：向子组件传递数据
  * 特点：可以船体任意数量和任意类型

* props校验

  * 作用：为组件的prop指定验证要求，不符合要求，控制台就会有错误提示

  * 语法

    * 类型校验

      * props：{要校验的属性：类型}

    * 非空校验

    * 默认值

    * 自定义校验

    * 完整写法

      ```vue
      props：{
      	 要校验的属性名：{
      			   type：类型，
          					 required：布尔值, //是否必填
      	   default:默认值,
           validator（value）{
      	     //自定义校验逻辑
             return 是否通过校验
         }
      	 }
      }
      ```

* prop&data 单向数据流

  * 共同点：都可以给组件提供数据
  * 区别：
    * data的数据是自己的 随便改
    * prop的数据是外部的 不能直接改，要遵循单向数据流
    * 单向数据流：父级prop的数据更新，会向下流动，影响子组件

* V-mpdel原理

  * v-model本质上是一个语法糖，就是value属性和input事件的合写
  * 数据变，视图跟着变：value
  * 视图变，数据跟着变 @input
  * 注意：$event用于模板中，获取事件的形参
  * ![image-20250812150055482](D:\study\lianxi\MyLearningDocuments\images\image-20250812150055482.png)

* 表单类组件封装

  * 父传子：数据应该是父组件props传递过来的，v-model拆解绑定数据
  * 子传父：监听输入，子传父传值给父组件修改
  * ![image-20250812151133708](D:\study\lianxi\MyLearningDocuments\images\image-20250812151133708.png)

* 通过v-model简化封装

  * ![image-20250812151430439](D:\study\lianxi\MyLearningDocuments\images\image-20250812151430439.png)

* .sync 修饰符

  * 作用：可以实现子组件与父组件数据的双向绑定，简化代码
  * 特点：prop属性名，可以自定义，非固定的value
  * 场景：封装弹框类的基础组件
  * 本质：就是：属性名和@update：属性名合写
  * ![image-20250813081124217](D:\study\lianxi\MyLearningDocuments\images\image-20250813081124217.png)
  * ![image-20250813081220425](D:\study\lianxi\MyLearningDocuments\images\image-20250813081220425.png)

* ref和$refs

  * 作用：可以用于获取dom元素，或组件实例
  * 特点：查找范围-》当前组件内
  * 获取dom
    * 给目标标签添加ref属性
    * ![image-20250813084222653](D:\study\lianxi\MyLearningDocuments\images\image-20250813084222653.png)
    * 在dom渲染之后，通过this.$refs.ref的值，获取元素
  * 获取组件
    * 给目标组件添加ref属性
    * ![image-20250813084645521](D:\study\lianxi\MyLearningDocuments\images\image-20250813084645521.png)
    * 在dom渲染之后，通过this.$refs.ref的值，获取目标组件，就可以调用组件对象里面的方法

* Vue异步更新、$nextTick

  * $nextTick：等待DOM更新后，才会触发执行此方法里的函数体
  * 语法：this.$nextTick(函数)